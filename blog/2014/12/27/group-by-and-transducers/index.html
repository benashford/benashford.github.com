<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="default-src 'self';font-src 'self' data:;img-src 'self' https://* data:;media-src 'self';style-src 'self' 'unsafe-inline';frame-src player.vimeo.com https://www.youtube-nocookie.com https://www.youtube.com;connect-src 'self' benashford.goatcounter.com/count;script-src 'self' gc.zgo.at 'self'" http-equiv=Content-Security-Policy><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://benashford.github.io name=base><title>
Ben Ashford • group-by and Transducers</title><link href="https://benashford.github.io/custom_subset.css?h=0b9535a28bc3d5bf2321" rel=stylesheet><link href="https://benashford.github.io/main.css?h=3716ab3457d2dd050b3c" rel=stylesheet><link href="https://benashford.github.io/custom.css?h=8033382f2c68f07d12a3" rel=stylesheet><meta content="light dark" name=color-scheme><meta content="Mildly interesting technology stories." name=description><meta content="Mildly interesting technology stories." property=og:description><meta content="group-by and Transducers" property=og:title><meta content=article property=og:type><meta content=en_GB property=og:locale><link href=https://benashford.github.io/blog/2014/12/27/group-by-and-transducers/ rel=canonical><meta content=https://benashford.github.io/blog/2014/12/27/group-by-and-transducers/ property=og:url><meta content="Ben Ashford" property=og:site_name><noscript><link href=https://benashford.github.io/no_js.css rel=stylesheet></noscript><script src=https://benashford.github.io/js/initializeTheme.min.js></script><script defer src=https://benashford.github.io/js/themeSwitcher.min.js></script><script async data-goatcounter=https://benashford.goatcounter.com/count src=https://gc.zgo.at/count.js></script><script src="https://benashford.github.io/search_index.en.js?h=194ee059cb93d534a980" defer></script><script src="https://benashford.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><a href=#main-content id=skip-link>Skip to content</a><header><nav class=navbar><div class=nav-title><a class=home-title href=https://benashford.github.io/>Ben Ashford</a></div><div class=nav-navs><ul><li><a class="nav-links no-hover-padding" href=https://benashford.github.io/blog/>blog </a><li><a class="nav-links no-hover-padding" href=https://benashford.github.io/archive/>archive </a><li><a class="nav-links no-hover-padding" href=https://benashford.github.io/about/>about </a><li class=menu-icons-container><ul class=menu-icons-group><li class="js menu-icon"><div aria-label="Click or press $SHORTCUT to open search" class="search-icon interactive-icon" title="Click or press $SHORTCUT to open search" id=search-button role=button tabindex=0><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="M784-120 532-372q-30 24-69 38t-83 14q-109 0-184.5-75.5T120-580q0-109 75.5-184.5T380-840q109 0 184.5 75.5T640-580q0 44-14 83t-38 69l252 252-56 56ZM380-400q75 0 127.5-52.5T560-580q0-75-52.5-127.5T380-760q-75 0-127.5 52.5T200-580q0 75 52.5 127.5T380-400Z"/></svg></div><li class="theme-switcher-wrapper js"><div aria-label="Toggle dark mode" title="Toggle dark/light mode" aria-pressed=false class=theme-switcher role=button tabindex=0></div><div aria-label="Reset mode to default" class="theme-resetter arrow" title="Reset mode to default" aria-hidden=true role=button tabindex=0></div></ul></ul></div></nav></header><div class=content id=main-content><main><article class=h-entry><h1 class="p-name article-title">group-by and Transducers</h1><a class="u-url u-uid" href=https://benashford.github.io/blog/2014/12/27/group-by-and-transducers/></a><ul class=meta><span class="hidden p-author h-card"> <a class=u-url href=https://benashford.github.io rel=author></a> </span><li><time class=dt-published datetime=2014-12-27>27th Dec 2014</time><li title="1859 words"><span aria-hidden=true class=separator>•</span>10 min read<li class=tag><span aria-hidden=true class=separator>•</span>Tags: <li class=tag><a class=p-category href=https://benashford.github.io/tags/clojure/>clojure</a>, <li class=tag><a class=p-category href=https://benashford.github.io/tags/transducers/>transducers</a></ul><section class="e-content body"><p>One of the random, but very useful, functions in <code>clojure.core</code> is the venerable <a href=https://clojure.github.io/clojure/clojure.core-api.html#clojure.core/group-by><code>group-by</code></a>. Simply take a collection of something, a function to extract a key, and it returns a map of the same data indexed by the key. It's incredibly useful, I use it all the time.<p>But it's also annoying. Why? Because often, perhaps even the majority of the time, I want to do some something with the values after they've been grouped; something that couldn't be done before hand. Examples of this include: a) removing the key used to index the data, b) applying functions that only make sense post-grouping - e.g. removing duplicate values.<p>Let use that first example to go into more detail. I often end-up dealing with data that is essentially a series of pairs, where the first element is an ID of some description, and the second is the data, often a map of some kind. Using completely made-up data, it often looks like this:<pre>
[[:a 1] [:a 2] [:b 3] [:a 4] [:c 5] [:b 6]]
</pre><p>Using <code>group-by</code> on this gives me:<pre>
{:a [[:a 1] [:a 2] [:a 4]], :b [[:b 3] [:b 6]], :c [[:c 5]]}
</pre><p>Which groups by the first element, as I ask, but the values contain much redundant data. So, of course I remove them afterwards, but this leads to ugly code as I iterate over this first map and produce a second one:</p><script src=https://gist.github.com/benashford/7b9820e56f510c19b1c3.js></script><p>The uglyness can be easily addressed by making this a generalised function so I'd never need to see the internals. Just as <code>group-by</code> takes a function to extract the key, this better group-by could take two functions - one to extract the key, the second to extract the value. Although this does still leave a problem of intermediate short-lived maps and sequences. I might as well not call the standard <code>group-by</code> at all, and just implement it all myself:</p><script src=https://gist.github.com/benashford/198bd6bc0ccb4220bda8.js></script><p>This maintains the key contract of <code>group-by</code>, namely returning a map with vectors as values, but strips out the data I'm not interested in:<pre>
group-transduce.core> (group-by-better first second example-data)
{:c [5], :b [3 6], :a [1 2 4]}
</pre><p>Much better. But hang on a minute, what about my other example. If I wanted to do other group-specific processing, like removing duplicates, I need to take apart the map and put it back together again; either that or create a number of distinct group-by functions for different circumstances. Neither of which felt like a particularly happy solution.<h3 id=transducers>Transducers</h3><p>Then, of course, the repressed memories of the various blog posts and videos regarding <a href=http://clojure.org/transducers>transducers</a> all came back. Is this, after all, the same sort of thing that transducers were invented for?<p>I won't try and explain in detail what transducers are, or how they work; many people with better credentials have tried, and still left confusion in their wake. See the HN discussion on the original announcement: <a href="https://news.ycombinator.com/item?id=8143905">https://news.ycombinator.com/item?id=8143905</a>. But they're not as complex as they might sound, if I were to try and explain in one single gross over-simplification I'd say they are an application of a higher-order function, but with "applied to" bit removed. So, in a usual application of a higher-order function you'd apply it to some data: <code>(map function data)</code>; but in Clojure 1.7: <code>(map function)</code> returns a transducer that can then be applied to, well, anything. A transducer could be applied over a collection, which would behave the same way as the pre-existing higher-order functions, but it doesn't have to be; it could, in theory, be applied during a group-by operation to achieve the goals I mentioned above in a single operation without temporary maps and sequences...<p>So, if I were to implement a <code>group-by-with-transducer</code> function (I can think of a better name later!) what parameters would it take? It would still need a function to extract a key for the data to be grouped by, then a transducer for what happens next, finally the data to be grouped. The equivalent of my previous <code>group-by-better</code> example above would be: <code>(group-by-with-transducer first (map second) data)</code>. This looks good to me, it reads as it does: group by the first element of the data, then map second over the results.<p>How would one implement such a function? Well, for starters, transducers can be stateful; this has two specific implications for this function: 1) we need one instance of the transducer for each group, and 2) we need to explicitly close the transducer at the end, to ensure that any state is flushed. Secondly, transducers can terminate early (think of the <code>take</code> function as an example), this needs to be taken into account; we can stop sending data through the transducer instance when this happens (although we do still need to close it).<p>What would this function look like? A bit like this:</p><script src=https://gist.github.com/benashford/a9ea85225f4984174235.js></script><p>The parameter <code>xf</code> is the transducer. <code>ff</code> is a function that returns the particular instance of the transducer for the given key; here we use <code>conj</code> as the reducing function for this instance of the transducer because we're building a vector for the value in the map.<p>The middle-part of the function is essentially the same as the <code>group-by-better</code> function before, but with the difference of passing each element of <code>data</code> through the instance of the transducer. This "instance of the transducer", as I've been calling it, is now performing the same action as <code>conj</code> did in the non-transducer examples; transducers turn one reducing function into another one. So if we called this function with <code>(map second)</code> as the value of <code>xf</code>, the function is doing the same thing as <code>(conj v (second d))</code>. And now suddenly transducers all make sense.<p>The final line of the function is closing the transducer. For stateless transducers this is a no-op, but for stateful transducers like the result of <code>(partition-all 3)</code> it flushes anything remaining, and for any reduced values (e.g. <code>take</code>) this unwraps it and returns the actual value. The final line also makes use of a transducer, which is interesting.<h3 id=testing>Testing</h3><pre>
group-transduce.core> (group-by-with-transducer first (map second) example-data)
{:c [5], :b [3 6], :a [1 2 4]}
</pre><p>Works a treat. Let's try it with a stateful transducer to make sure that works, I'll partition the values of the map using <code>(paritition-all 2)</code>:<pre>
group-transduce.core> (def xf (comp (map second) (partition-all 2)))
#'group-transduce.core/xf
group-transduce.core> (group-by-with-transducer first xf example-data)
{:c [[5]], :b [[3 6]], :a [[1 2] [4]]}
</pre><p>Let's also try with an early-terminating operation:<pre>
group-transduce.core> (group-by-with-transducer first (comp (map second) (take 2)) example-data)
{:c [5], :b [3 6], :a [1 2]}
</pre><p>Nice.<h3 id=performance>Performance</h3><p>There are two advantages of this transducer based approach.<p>Firstly, it's less code. We have one reusable function <code>group-by-with-transducer</code> (note to self: really must find a better name), and any subsequent operations are composable predictable transducers.<p>Secondly, it ought to be faster. There's less intermediate data, it's just function calls. But, notwithstanding my previous warnings <a href=/blog/2014/12/07/the-folly-of-benchmarks/>on the folly of benchmarking</a>, I can't make claims on performance without testing it.<p>But first we need to invent a meaningful test. Let's use my original use-case. We have a vector which is a series of 1,000 pairs; we want to group by the first value of each pair, then collect the second removing duplicates as we go. Then I can compare an old-school implemetation with one that calls <code>group-by-with-transducer</code>.<h4 id=the-test-data>The test data</h4><p>I'll create some randomly generated test data to use:<pre>
group-transduce.core> (def ks [:a :b :c :d :e :f :g :h :i :j])
#'group-transduce.core/ks
group-transduce.core> (def vs (into [] (range 50)))
#'group-transduce.core/vs
group-transduce.core> (def test-data (take 1000 (repeatedly (fn [] [(rand-nth ks) (rand-nth vs)]))))
#'group-transduce.core/test-data
group-transduce.core> (take 5 test-data)
([:c 13] [:j 38] [:j 3] [:f 19] [:g 12])
</pre><h4 id=the-old-school-version-without-using-transducers>The old-school version (without using transducers)</h4><p>Creating a function to use as the 'control' in an experiment is always controversial. It would be very easy to create a bad implementation, just to show how dramatically better the new version is; similarly it would be easy to create a custom function that does exactly what it needs to do, this would be fast, but wouldn't be the type of code you would see in-the-wild. For the purposes of this test I will use a variation of the example I gave in the opening paragraphs:</p><script src=https://gist.github.com/benashford/5ac62f26a6d568f2f244.js></script><p>This does test both composing standard functions where possible with performing post-grouping actions in a fairly direct way.<p>How does this perform? Tested with Clojure 1.7.0alpha4, using the Criterium library to benchmark the function:<pre>
group-transduce.core> (bench (complex-example-1 test-data))
Evaluation count : 70620 in 60 samples of 1177 calls.
             Execution time mean : 857.557453 µs
    Execution time std-deviation : 19.955623 µs
   Execution time lower quantile : 821.684737 µs ( 2.5%)
   Execution time upper quantile : 895.128919 µs (97.5%)
                   Overhead used : 1.764232 ns
</pre><p>The headline number is 0.858ms to transform the data as described.<h4 id=the-new-version-using-transducers>The new version (using transducers)</h4><p>The first hurdle here is that I need a <code>distinct</code> transducer, but there isn't one in the standard library. So I will create one myself<sup class=footnote-reference><a href=#1>1</a></sup>, I base this on how other transducers are implemented; you will also see it is a stateful transducer.</p><script src=https://gist.github.com/benashford/94307b42547029e9fba1.js></script><p>Let's just test this to make sure it works:<pre>
group-transduce.core> (group-by-with-transducer first (comp (map second) (distinct-transducer)) [[:a 1] [:b 2] [:b 1] [:b 2]])
{:b [2 1], :a [1]}
</pre><p>And then plug it in to our test harness:</p><script src=https://gist.github.com/benashford/6461848ad579d271f163.js></script><p>And then benchmark it using the same test data as the previous benchmark:<pre>
group-transduce.core> (bench (complex-example-2 test-data))
                Evaluation count : 85080 in 60 samples of 1418 calls.
             Execution time mean : 713.997396 µs
    Execution time std-deviation : 11.890208 µs
   Execution time lower quantile : 695.413537 µs ( 2.5%)
   Execution time upper quantile : 731.740410 µs (97.5%)
                   Overhead used : 1.764232 ns
</pre><p>The headline number is 0.714ms. Which is faster by 0.144ms, or 17% faster... not to be sniffed at.<h3 id=conclusion>Conclusion</h3><p>The time saved by not using intermediate sequences and data-structures is actually quite significant. Add to this the fact that transducers allow kinds of composition that weren't possible before, not without constructing multiple versions of the similar functions, and it immediately seems that transducers are the answer to a wide array of situations.<p>##### Footnotes #####<div class=footnote-definition id=1><sup class=footnote-definition-label>1</sup><p>See my previous controversy disclaimer.</div></section></article></main><div id=button-container><div id=toc-floating-container><input class=toggle id=toc-toggle type=checkbox><label class=overlay for=toc-toggle></label><label title="Toggle Table of Contents" class=button for=toc-toggle id=toc-button><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="M414.82-193.094q-18.044 0-30.497-12.32-12.453-12.319-12.453-30.036t12.453-30.086q12.453-12.37 30.497-12.37h392.767q17.237 0 29.927 12.487 12.69 12.486 12.69 30.203 0 17.716-12.69 29.919t-29.927 12.203H414.82Zm0-244.833q-18.044 0-30.497-12.487Q371.87-462.9 371.87-480.45t12.453-29.92q12.453-12.369 30.497-12.369h392.767q17.237 0 29.927 12.511 12.69 12.512 12.69 29.845 0 17.716-12.69 30.086-12.69 12.37-29.927 12.37H414.82Zm0-245.167q-18.044 0-30.497-12.32t-12.453-30.037q0-17.716 12.453-30.086 12.453-12.369 30.497-12.369h392.767q17.237 0 29.927 12.486 12.69 12.487 12.69 30.203 0 17.717-12.69 29.92-12.69 12.203-29.927 12.203H414.82ZM189.379-156.681q-32.652 0-55.878-22.829t-23.226-55.731q0-32.549 23.15-55.647 23.151-23.097 55.95-23.097 32.799 0 55.313 23.484 22.515 23.484 22.515 56.246 0 32.212-22.861 54.893-22.861 22.681-54.963 22.681Zm0-245.167q-32.652 0-55.878-23.134-23.226-23.135-23.226-55.623 0-32.487 23.467-55.517t56.12-23.03q32.102 0 54.721 23.288 22.62 23.288 22.62 55.775 0 32.488-22.861 55.364-22.861 22.877-54.963 22.877Zm-.82-244.833q-32.224 0-55.254-23.288-23.03-23.289-23.03-55.623 0-32.333 23.271-55.364 23.272-23.03 55.495-23.03 32.224 0 55.193 23.288 22.969 23.289 22.969 55.622 0 32.334-23.21 55.364-23.21 23.031-55.434 23.031Z"/></svg></label><div class=toc-content><div class=toc-container><ul><li><a href=https://benashford.github.io/blog/2014/12/27/group-by-and-transducers/#transducers>Transducers</a><li><a href=https://benashford.github.io/blog/2014/12/27/group-by-and-transducers/#testing>Testing</a><li><a href=https://benashford.github.io/blog/2014/12/27/group-by-and-transducers/#performance>Performance</a> <ul><li><a href=https://benashford.github.io/blog/2014/12/27/group-by-and-transducers/#the-test-data>The test data</a><li><a href=https://benashford.github.io/blog/2014/12/27/group-by-and-transducers/#the-old-school-version-without-using-transducers>The old-school version (without using transducers)</a><li><a href=https://benashford.github.io/blog/2014/12/27/group-by-and-transducers/#the-new-version-using-transducers>The new version (using transducers)</a></ul><li><a href=https://benashford.github.io/blog/2014/12/27/group-by-and-transducers/#conclusion>Conclusion</a></ul></div></div></div><a title="Go to the top of the page" class=no-hover-padding href=# id=top-button> <svg viewbox="0 0 20 20" fill=currentColor><path d="M3.293 9.707a1 1 0 010-1.414l6-6a1 1 0 011.414 0l6 6a1 1 0 01-1.414 1.414L11 5.414V17a1 1 0 11-2 0V5.414L4.707 9.707a1 1 0 01-1.414 0z"/></svg> </a></div><span class=hidden id=copy-success> Copied! </span><span class=hidden id=copy-init> Copy code to clipboard </span><script defer src=https://benashford.github.io/js/copyCodeToClipboard.min.js></script></div><footer><section><nav class="socials nav-navs"><ul><li><a class="nav-links no-hover-padding social" rel=" me" href=https://github.com/benashford> <img alt=github loading=lazy src=https://benashford.github.io/social_icons/github.svg title=github> </a><li><a class="nav-links no-hover-padding social" rel=" me" href=https://uk.linkedin.com/in/benashford> <img alt=linkedin loading=lazy src=https://benashford.github.io/social_icons/linkedin.svg title=linkedin> </a></ul></nav><nav class=nav-navs></nav><div class=credits><small> Powered by <a href=https://www.getzola.org>Zola</a> & <a href=https://github.com/welpo/tabi>tabi</a> </small></div></section><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><h1 class=visually-hidden id=modalTitle>Search</h1><div id=modal-content><div id=searchBar><div aria-hidden=true class=search-icon><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="M784-120 532-372q-30 24-69 38t-83 14q-109 0-184.5-75.5T120-580q0-109 75.5-184.5T380-840q109 0 184.5 75.5T640-580q0 44-14 83t-38 69l252 252-56 56ZM380-400q75 0 127.5-52.5T560-580q0-75-52.5-127.5T380-760q-75 0-127.5 52.5T200-580q0 75 52.5 127.5T380-400Z"/></svg></div><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search… role=combobox spellcheck=false><div class="close-icon interactive-icon" title="Clear search" id=clear-search role=button tabindex=0><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></div></div><div id=results-container><div id=results-info><span id=zero_results> No results</span><span id=one_results> $NUMBER result</span><span id=many_results> $NUMBER results</span><span id=two_results> $NUMBER results</span><span id=few_results> $NUMBER results</span></div><div id=results role=listbox></div></div></div></div></footer><script src=https://benashford.github.io/js/lightbox.js></script>