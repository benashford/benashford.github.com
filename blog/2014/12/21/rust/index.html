<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="default-src 'self';font-src 'self' data:;img-src 'self' https://* data:;media-src 'self';style-src 'self' 'unsafe-inline';frame-src player.vimeo.com https://www.youtube-nocookie.com https://www.youtube.com;connect-src 'self' benashford.goatcounter.com/count;script-src 'self' gc.zgo.at 'self'" http-equiv=Content-Security-Policy><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://benashford.github.io name=base><title>
Ben Ashford • Rust</title><link href="https://benashford.github.io/custom_subset.css?h=0b9535a28bc3d5bf2321" rel=stylesheet><link href="https://benashford.github.io/main.css?h=3716ab3457d2dd050b3c" rel=stylesheet><link href="https://benashford.github.io/custom.css?h=8033382f2c68f07d12a3" rel=stylesheet><meta content="light dark" name=color-scheme><meta content="Mildly interesting technology stories." name=description><meta content="Mildly interesting technology stories." property=og:description><meta content=Rust property=og:title><meta content=article property=og:type><meta content=en_GB property=og:locale><link href=https://benashford.github.io/blog/2014/12/21/rust/ rel=canonical><meta content=https://benashford.github.io/blog/2014/12/21/rust/ property=og:url><meta content="Ben Ashford" property=og:site_name><noscript><link href=https://benashford.github.io/no_js.css rel=stylesheet></noscript><script src=https://benashford.github.io/js/initializeTheme.min.js></script><script defer src=https://benashford.github.io/js/themeSwitcher.min.js></script><script async data-goatcounter=https://benashford.goatcounter.com/count src=https://gc.zgo.at/count.js></script><script src="https://benashford.github.io/search_index.en.js?h=194ee059cb93d534a980" defer></script><script src="https://benashford.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><a href=#main-content id=skip-link>Skip to content</a><header><nav class=navbar><div class=nav-title><a class=home-title href=https://benashford.github.io/>Ben Ashford</a></div><div class=nav-navs><ul><li><a class="nav-links no-hover-padding" href=https://benashford.github.io/blog/>blog </a><li><a class="nav-links no-hover-padding" href=https://benashford.github.io/archive/>archive </a><li><a class="nav-links no-hover-padding" href=https://benashford.github.io/about/>about </a><li class=menu-icons-container><ul class=menu-icons-group><li class="js menu-icon"><div aria-label="Click or press $SHORTCUT to open search" class="search-icon interactive-icon" title="Click or press $SHORTCUT to open search" id=search-button role=button tabindex=0><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="M784-120 532-372q-30 24-69 38t-83 14q-109 0-184.5-75.5T120-580q0-109 75.5-184.5T380-840q109 0 184.5 75.5T640-580q0 44-14 83t-38 69l252 252-56 56ZM380-400q75 0 127.5-52.5T560-580q0-75-52.5-127.5T380-760q-75 0-127.5 52.5T200-580q0 75 52.5 127.5T380-400Z"/></svg></div><li class="theme-switcher-wrapper js"><div aria-label="Toggle dark mode" title="Toggle dark/light mode" aria-pressed=false class=theme-switcher role=button tabindex=0></div><div aria-label="Reset mode to default" class="theme-resetter arrow" title="Reset mode to default" aria-hidden=true role=button tabindex=0></div></ul></ul></div></nav></header><div class=content id=main-content><main><article class=h-entry><h1 class="p-name article-title">Rust</h1><a class="u-url u-uid" href=https://benashford.github.io/blog/2014/12/21/rust/></a><ul class=meta><span class="hidden p-author h-card"> <a class=u-url href=https://benashford.github.io rel=author></a> </span><li><time class=dt-published datetime=2014-12-21>21st Dec 2014</time><li title="1109 words"><span aria-hidden=true class=separator>•</span>6 min read<li class=tag><span aria-hidden=true class=separator>•</span>Tags: <li class=tag><a class=p-category href=https://benashford.github.io/tags/clojure/>clojure</a>, <li class=tag><a class=p-category href=https://benashford.github.io/tags/rust/>rust</a></ul><section class="e-content body"><p>Like every other developer on the internet, I've been watching the rise of <a href=http://www.rust-lang.org>Rust</a> with interest. I've spent the majority of my career in high-level language land, although I did do a lot of C++ once upon a time, and Rust may have passed me by with it's focus around low-level concerns, bringing back bad memories of C++<sup class=footnote-reference><a href=#1>1</a></sup>. However, the sheer buzz surrounding it, and the fact that they're now close to version 1.0 made me take another look.<p>And I'm glad I did take another look as it has rapidly progressed since the last time I looked into it. It's good to see a new language with new ideas, rather than a "a mix of X and Y" which seems more common. It bills itself as a "systems language", which it certainly is, but it also has a wide-array of high-level features too - first-class functions, higher-order functions, etc., being particularly interesting to see as someone with prior experience of functional programming languages.<p>Inspired by this, I decided to write something in Rust. Particularly the <a href=/blog/2014/03/22/the-power-of-lazy-sequences>LazySort algorithm</a> I've used for testing previously<sup class=footnote-reference><a href=#2>2</a></sup>.<h3 id=equivalences-and-differences>Equivalences and differences</h3><p>The first and most obvious difference between Clojure and Rust is that Rust is statically typed, and very strictly statically typed too, there's no Java-style bodging and casting, things aren't nullable by default. This means there will be no general <code>lazy-seq</code> as per Clojure.<p>The second and most fundamental difference between Rust and, well, everything really, is it's approach to memory management. It is not garbage collected, nor does it have C-style manual memory management<sup class=footnote-reference><a href=#3>3</a></sup>. Instead it has a concept of a lifetime: everything allocated has a deterministic point where it will be deallocated; and passing these values around by reference involves the compiler checking that the borrowed reference will not out-live the lifetime. To return a value up the stack, higher than the place it was allocated, you either need to: copy the value, or return a boxed value, which is a special type of reference that can be moved to a different owner. This is only the tip-of-the-iceberg into the compile-time checking Rust performs, it also protects against data-races by allowing only one mutable reference to exist at any point-in-time, for example.<p>But it does have something that behaves a bit like a Clojure lazy sequence: the <a href=http://doc.rust-lang.org/std/iter/trait.Iterator.html><code>Iterator</code></a>. So in theory it will be possible to create a kind of 'sorted' iterator that will return the values in a collection in sorted order, by sorting the underlying collection element-by-element, in the same way the Clojure implementation did.<h3 id=the-implementation>The implementation</h3><p>The finished version is available here: <a href=https://github.com/benashford/rust-lazysort>https://github.com/benashford/rust-lazysort</a>, and also on <a href=http://crates.io>crates.io</a> (the Rust package platform) here: <a href=https://crates.io/crates/lazysort>https://crates.io/crates/lazysort</a><p>One of the higher-level features that Rust supports is extension methods, which proved very useful in this case, it enabled me to add a method to any iterator which would convert it into a sorted iterator. This allows it to be chained with other Iterator functions:</p><script src=https://gist.github.com/benashford/ce690c260fe953f66b3f.js></script><p>The compiler's impressive type-checking is so sophisticated that trying to call <code>sorted()</code> on an iterator of <code>T</code> is a compile-error unless <code>T</code> implements the <a href=http://doc.rust-lang.org/std/cmp/trait.Ord.html><code>Ord</code></a> trait, which means the type has a default order. The function <code>sorted</code> simply doesn't exist otherwise. There is a second function <code>sorted_by</code> that can be called on any iterator, regardless of content, this requires that a closure be given defining the order:</p><script src=https://gist.github.com/benashford/74bf5caf61551ae27449.js></script><p>The extension methods are hygenic in the sense that they only apply if you import them:</p><script src=https://gist.github.com/benashford/cf938a57b440d9f92f37.js></script><h4 id=the-algorithm>The algorithm</h4><p>Originally it was a fairly naive port of the Clojure version, i.e. it used immutable vectors containing the broken-down underlying data as it was gradually sorted. This was later replaced with a version that was more idiomatic for Rust. It was the same algorithm, a lazy quicksort, but the second one was in-place rather than immutable. Although it worked on a copy of the underlying data, or original vector (or whatever it may have been) was untouched and didn't need to be marked as mutable.<h3 id=performance>Performance</h3><p>Rust aims for C++-levels of performance, which is a very high-bar indeed. It uses LLVM for the final compilation steps, so it already takes advantage of a mature compiler. Rust is also a fast-moving target, so much so that during the short period I was working on this, testing it against nightly builds the measured performance got noticibly faster without me having to do anything.<p>This, however, made judging the utility of lazy-sorting as a concept really quite difficult. At one stage the cost of lazily-sorting a full large vector was only 15% worse than the sort function in the standard library; small enough that a developer could consider using it for all purposes, not just the usual optimisation for short-cutting the sorting process of only partially consuming the full set of data. But at the time of writing, even though my code got faster with the latest nightly builds of Rust, the standard library sort got much, much faster! The end result is that the overhead for a full large vector is around 2.5 times, so probably not something you'd want to use all the time.<p>However the same benefits as found in the Clojure version were also found in the Rust version - e.g. taking the top 1,000 results. In the tests of 50,000 random numbers, the cross-over point is just over 10,000. Interestingly this is much better than the Clojure version, where the cross-over is around 1,250.<p>The headline numbers are that the Rust version is significantly faster than the Clojure version. Using the test of picking the top 1,000 out of 50,000 random numbers; the Clojure version manages an average of 11.2ms, the Rust version <a href=https://github.com/benashford/rust-lazysort#implementation-details-and-performance>0.9ms</a>.<h3 id=in-conclusion>In conclusion</h3><p>Bring on version 1.0.<h4 id=footnotes>Footnotes</h4><div class=footnote-definition id=1><sup class=footnote-definition-label>1</sup><p>I appreciate that C++ has changed a lot since then. In those dark days finding a compiler that supported STL was a nice surprise.</div><div class=footnote-definition id=2><sup class=footnote-definition-label>2</sup><p>Don't worry, the next blog post will be on a different subject entirely.</div><div class=footnote-definition id=3><sup class=footnote-definition-label>3</sup><p>Not strictly true, depending on how deep you want to get into <code>unsafe</code> blocks.</div></section></article></main><div id=button-container><div id=toc-floating-container><input class=toggle id=toc-toggle type=checkbox><label class=overlay for=toc-toggle></label><label title="Toggle Table of Contents" class=button for=toc-toggle id=toc-button><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="M414.82-193.094q-18.044 0-30.497-12.32-12.453-12.319-12.453-30.036t12.453-30.086q12.453-12.37 30.497-12.37h392.767q17.237 0 29.927 12.487 12.69 12.486 12.69 30.203 0 17.716-12.69 29.919t-29.927 12.203H414.82Zm0-244.833q-18.044 0-30.497-12.487Q371.87-462.9 371.87-480.45t12.453-29.92q12.453-12.369 30.497-12.369h392.767q17.237 0 29.927 12.511 12.69 12.512 12.69 29.845 0 17.716-12.69 30.086-12.69 12.37-29.927 12.37H414.82Zm0-245.167q-18.044 0-30.497-12.32t-12.453-30.037q0-17.716 12.453-30.086 12.453-12.369 30.497-12.369h392.767q17.237 0 29.927 12.486 12.69 12.487 12.69 30.203 0 17.717-12.69 29.92-12.69 12.203-29.927 12.203H414.82ZM189.379-156.681q-32.652 0-55.878-22.829t-23.226-55.731q0-32.549 23.15-55.647 23.151-23.097 55.95-23.097 32.799 0 55.313 23.484 22.515 23.484 22.515 56.246 0 32.212-22.861 54.893-22.861 22.681-54.963 22.681Zm0-245.167q-32.652 0-55.878-23.134-23.226-23.135-23.226-55.623 0-32.487 23.467-55.517t56.12-23.03q32.102 0 54.721 23.288 22.62 23.288 22.62 55.775 0 32.488-22.861 55.364-22.861 22.877-54.963 22.877Zm-.82-244.833q-32.224 0-55.254-23.288-23.03-23.289-23.03-55.623 0-32.333 23.271-55.364 23.272-23.03 55.495-23.03 32.224 0 55.193 23.288 22.969 23.289 22.969 55.622 0 32.334-23.21 55.364-23.21 23.031-55.434 23.031Z"/></svg></label><div class=toc-content><div class=toc-container><ul><li><a href=https://benashford.github.io/blog/2014/12/21/rust/#equivalences-and-differences>Equivalences and differences</a><li><a href=https://benashford.github.io/blog/2014/12/21/rust/#the-implementation>The implementation</a> <ul><li><a href=https://benashford.github.io/blog/2014/12/21/rust/#the-algorithm>The algorithm</a></ul><li><a href=https://benashford.github.io/blog/2014/12/21/rust/#performance>Performance</a><li><a href=https://benashford.github.io/blog/2014/12/21/rust/#in-conclusion>In conclusion</a> <ul><li><a href=https://benashford.github.io/blog/2014/12/21/rust/#footnotes>Footnotes</a></ul></ul></div></div></div><a title="Go to the top of the page" class=no-hover-padding href=# id=top-button> <svg viewbox="0 0 20 20" fill=currentColor><path d="M3.293 9.707a1 1 0 010-1.414l6-6a1 1 0 011.414 0l6 6a1 1 0 01-1.414 1.414L11 5.414V17a1 1 0 11-2 0V5.414L4.707 9.707a1 1 0 01-1.414 0z"/></svg> </a></div><span class=hidden id=copy-success> Copied! </span><span class=hidden id=copy-init> Copy code to clipboard </span><script defer src=https://benashford.github.io/js/copyCodeToClipboard.min.js></script></div><footer><section><nav class="socials nav-navs"><ul><li><a class="nav-links no-hover-padding social" rel=" me" href=https://github.com/benashford> <img alt=github loading=lazy src=https://benashford.github.io/social_icons/github.svg title=github> </a><li><a class="nav-links no-hover-padding social" rel=" me" href=https://uk.linkedin.com/in/benashford> <img alt=linkedin loading=lazy src=https://benashford.github.io/social_icons/linkedin.svg title=linkedin> </a></ul></nav><nav class=nav-navs></nav><div class=credits><small> Powered by <a href=https://www.getzola.org>Zola</a> & <a href=https://github.com/welpo/tabi>tabi</a> </small></div></section><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><h1 class=visually-hidden id=modalTitle>Search</h1><div id=modal-content><div id=searchBar><div aria-hidden=true class=search-icon><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="M784-120 532-372q-30 24-69 38t-83 14q-109 0-184.5-75.5T120-580q0-109 75.5-184.5T380-840q109 0 184.5 75.5T640-580q0 44-14 83t-38 69l252 252-56 56ZM380-400q75 0 127.5-52.5T560-580q0-75-52.5-127.5T380-760q-75 0-127.5 52.5T200-580q0 75 52.5 127.5T380-400Z"/></svg></div><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search… role=combobox spellcheck=false><div class="close-icon interactive-icon" title="Clear search" id=clear-search role=button tabindex=0><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></div></div><div id=results-container><div id=results-info><span id=zero_results> No results</span><span id=one_results> $NUMBER result</span><span id=many_results> $NUMBER results</span><span id=two_results> $NUMBER results</span><span id=few_results> $NUMBER results</span></div><div id=results role=listbox></div></div></div></div></footer><script src=https://benashford.github.io/js/lightbox.js></script>