<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="default-src 'self';font-src 'self' data:;img-src 'self' https://* data:;media-src 'self';style-src 'self' 'unsafe-inline';frame-src player.vimeo.com https://www.youtube-nocookie.com https://www.youtube.com;connect-src 'self' benashford.goatcounter.com/count;script-src 'self' gc.zgo.at 'self'" http-equiv=Content-Security-Policy><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://benashford.github.io name=base><title>
Ben Ashford • Building an Event-based Redis Client in Java</title><link href="https://benashford.github.io/custom_subset.css?h=0b9535a28bc3d5bf2321" rel=stylesheet><link href="https://benashford.github.io/main.css?h=3716ab3457d2dd050b3c" rel=stylesheet><link href="https://benashford.github.io/custom.css?h=8033382f2c68f07d12a3" rel=stylesheet><meta content="light dark" name=color-scheme><meta content="Mildly interesting technology stories." name=description><meta content="Mildly interesting technology stories." property=og:description><meta content="Building an Event-based Redis Client in Java" property=og:title><meta content=article property=og:type><meta content=en_GB property=og:locale><link href=https://benashford.github.io/blog/2015/09/13/building-an-event-based-redis-client-in-java/ rel=canonical><meta content=https://benashford.github.io/blog/2015/09/13/building-an-event-based-redis-client-in-java/ property=og:url><meta content="Ben Ashford" property=og:site_name><noscript><link href=https://benashford.github.io/no_js.css rel=stylesheet></noscript><script src=https://benashford.github.io/js/initializeTheme.min.js></script><script defer src=https://benashford.github.io/js/themeSwitcher.min.js></script><script async data-goatcounter=https://benashford.goatcounter.com/count src=https://gc.zgo.at/count.js></script><script src="https://benashford.github.io/search_index.en.js?h=194ee059cb93d534a980" defer></script><script src="https://benashford.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><a href=#main-content id=skip-link>Skip to content</a><header><nav class=navbar><div class=nav-title><a class=home-title href=https://benashford.github.io/>Ben Ashford</a></div><div class=nav-navs><ul><li><a class="nav-links no-hover-padding" href=https://benashford.github.io/blog/>blog </a><li><a class="nav-links no-hover-padding" href=https://benashford.github.io/archive/>archive </a><li><a class="nav-links no-hover-padding" href=https://benashford.github.io/about/>about </a><li class=menu-icons-container><ul class=menu-icons-group><li class="js menu-icon"><div aria-label="Click or press $SHORTCUT to open search" class="search-icon interactive-icon" title="Click or press $SHORTCUT to open search" id=search-button role=button tabindex=0><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="M784-120 532-372q-30 24-69 38t-83 14q-109 0-184.5-75.5T120-580q0-109 75.5-184.5T380-840q109 0 184.5 75.5T640-580q0 44-14 83t-38 69l252 252-56 56ZM380-400q75 0 127.5-52.5T560-580q0-75-52.5-127.5T380-760q-75 0-127.5 52.5T200-580q0 75 52.5 127.5T380-400Z"/></svg></div><li class="theme-switcher-wrapper js"><div aria-label="Toggle dark mode" title="Toggle dark/light mode" aria-pressed=false class=theme-switcher role=button tabindex=0></div><div aria-label="Reset mode to default" class="theme-resetter arrow" title="Reset mode to default" aria-hidden=true role=button tabindex=0></div></ul></ul></div></nav></header><div class=content id=main-content><main><article class=h-entry><h1 class="p-name article-title">Building an Event-based Redis Client in Java</h1><a class="u-url u-uid" href=https://benashford.github.io/blog/2015/09/13/building-an-event-based-redis-client-in-java/></a><ul class=meta><span class="hidden p-author h-card"> <a class=u-url href=https://benashford.github.io rel=author></a> </span><li><time class=dt-published datetime=2015-09-13>13th Sep 2015</time><li title="1369 words"><span aria-hidden=true class=separator>•</span>7 min read</ul><section class="e-content body"><h2 id=the-story-so-far>The story so far</h2><p>(You may want to skip this part, if you have already read my previous blog post on the subject: <a href=/blog/2015/06/02/java-in-a-polygot-jvm-world>Java in a polyglot JVM world</a>)<p>A few months ago, I had an idea for a project that required a certain amount of data-processing. Nothing very sophisticated, but potentially very time consuming. As with a lot of projects, there were a wealth of open-source libraries that would get me 95% of the way; these could be integrated into a pipeline based on Clojure's <code>core.async</code>. However one thing was missing: state, each process (there may have been more than one) would need to know what work remained; if this state were lost, everything would have to begin from scratch.<p>As things happened, I quickly realised the scope was much smaller than I had reckoned, so I quickly reached my goal with a single Ruby script and a SQLite database. But the seed had been sewn, I wanted a way of talking to Redis is a non-blocking way, so it could be integrated with Clojure's <code>core.async</code>. That quickly became the <a href=https://github.com/benashford/redis-async><code>redis-async</code> project</a>.<p>However, the initial performance of this project was poor. Poor enough, compared to pre-existing non-async Redis clients that it nullified the existence of the project, no-one (not even me) would use it in that state. So I began to investigate the poor performance, and fix things. This gave birth to the <a href=https://github.com/benashford/jresp>JRESP project</a>. The process and rationale of this changes I described in the earlier blog post: <a href=/blog/2015/06/02/java-in-a-polygot-jvm-world>Java in a polyglot JVM world</a>.<p>This led to much improved performance for <code>redis-async</code>, with most of the high-level code in Clojure but the low-level code (serialisation, sockets, etc.) in Java.<p>But there was still more to do...<p>Performance was still an order of magnitude poorer than the competition. I had many theories for this, mostly revolving around two themes: 1) the more complex nature of parsing results in an event-based system, you can't just read bytes from an <code>InputStream</code>; and, 2) the complex handling of multiplexing many Redis commands onto a single connection with implicit pipelining.<p>This gave me two avenues to explore to make things better.<h2 id=why-pipelining>Why pipelining?</h2><p>To make the most efficient use of the connection. Each Redis command is (typically, there are some exceptions) small; rather than waiting for a response for each command, it is more efficient to send multiple commands, then wait for all of the corresponding responses. The official Redis docs have a <a href=http://redis.io/topics/pipelining>good explanation of this, and benchmarks</a>.<p>Most traditional clients make pipelining the responsibility of the application developer. Typically by declaring a block that contains multiple Redis commands, the block then returns a single collection containing all of the results<sup class=footnote-reference><a href=#1>1</a></sup>.<p>The advantage of an asynchronous and/or event-based approach is that pipelining can be achieved done automatically<sup class=footnote-reference><a href=#2>2</a></sup>. If an application is issuing ten commands in quick succession, since it doesn't wait for responses immediately these can all be combined into a single request/response cycle. This should make the application code cleaner, and also, potentially, discover additional efficiencies if there are multiple threads issuing commands at the same time, they could all be combined into one single request/response cycle.<p>The downside is that none of this can be guaranteed, since the code cannot know when these breaks are. Instead it relies on the principal that issuing commands will be faster than writing to a socket, so each socket write will be fully utilised in the sense that all commands issued in the interim will be included. But there will undoubtedly be some edge-cases where the worst-case occurs.<p>As with most different approaches to common problems, there are tradeoffs, and there is an upside to the non-determinism. In the case of very-large numbers of commands in a single pipeline (hundreds of thousands), there is a latency problem in existing synchronous clients - the first command won't be actually sent until all the commands have been issued, and the first response won't be parsed until all commands have been sent - but with implicit pipelining the stream will be naturally batched into smaller chunks, something that would have to be done manually using other approaches.<p>The goal, therefore, is that using JRESP and <code>redis-async</code> in a naive way will be more efficient than using existing synchronous clients in a naive way, even if you use pipelining.<h2 id=implicit-pipelining>Implicit pipelining</h2><p>The way <code>redis-async</code> implemented implicit pipelining was at the <code>core.async</code> layer. Essentially whenever an outgoing command went through the outgoing (buffered) channel, before sending it to Redis (via JRESP) any other commands on the channel were also taken (but it wouldn't wait for any more), these would be read into a vector which would be passed to JRESP. This still had the latency problem if there was a large number of commands.<p>The most recent change has been to move this responsibility out of the Clojure layer and into the Java layer. This has resulted in two key benefits: 1) a great simplification of the Clojure code, there's no need for an outgoing channel anymore, each Redis command is a thin wrapper calling the underling JRESP <code>write</code> method; and, 2) it means the implicit pipelining can be done in sync with the low-level socket signalling using Java's NIO package.<p>Now, when a command is issued from <code>redis-async</code> this corresponds with a single method call to JRESP. The command will be serialised into a <code>java.nio.ByteBuffer</code> and added to a queue. The queue compacts multiple byte buffers up to a maximum size - essentially the size of one TCP packet. Each connection pool (a new addition to JRESP) has a thread dedicated to all the sockets it controls, this uses a <code>java.nio.channels.Selector</code> and the state of each queue to be notified when each socket is ready for reading or writing.<h2 id=conclusion>Conclusion</h2><p>This new approach has resulted in a significant gain in throughput compared to previously. I'm planning on doing a comprehensive set of performance tests, but so far been using the same micro-benchmarks I mentioned in the previous post. On those measures <code>redis-async</code> performance is between 10% faster and 100% slower than Carmine; although, interestingly, JRESP alone seems to be 25% faster than Jedis. These numbers feel counter intuitive somehow, as either Carmine is faster than Jedis, which other benchmarks show not to be the case, or this heavily implies the difference in performance is due to the Clojure layer of <code>redis-async</code> above JRESP<sup class=footnote-reference><a href=#3>3</a></sup>... but I need to investigate more to both prove these interim results and to provide enough test cases to improve things further, the micro-benchmarks are too unrealistic to draw conclusions.<p>But, what is significant is the progress of improving performance as I've gone though these refinements. From one hundred times slower to more-or-less<sup class=footnote-reference><a href=#4>4</a></sup> the same speed.<p>The final question, what's to stop JRESP being a full-blown Redis client in its own right? Not a lot actually, it now has all of the requisite parts, but it's not a particular priority given the wealth of alternative Java clients. But all that is needed is a facade class containing methods for each Redis command, in <code>redis-async</code> this is automatically generated from the <a href=https://github.com/antirez/redis-doc/blob/master/commands.json>list of commands provided by redis-doc</a>; obviously the meta-programming nature of Clojure makes this easy, I'll need to find use an external tool to do the same with JRESP.<h3 id=footnotes>Footnotes</h3><div class=footnote-definition id=1><sup class=footnote-definition-label>1</sup><p>The previous link to the Redis docs also contain code showing this in effect.</div><div class=footnote-definition id=2><sup class=footnote-definition-label>2</sup><p><code>redis-async</code>'s README shows proof and examples of this: <a href=https://github.com/benashford/redis-async#implicit-pipelining>https://github.com/benashford/redis-async#implicit-pipelining</a></div><div class=footnote-definition id=3><sup class=footnote-definition-label>3</sup><p>My immediate guess is that <code>redis-async</code> is slower at issuing the commands; but JRESP will be sending data to Redis at the same speed. The end result being less efficient throughput.</div><div class=footnote-definition id=4><sup class=footnote-definition-label>4</sup><p>Within one order-of-magnitude.</div></section></article></main><div id=button-container><div id=toc-floating-container><input class=toggle id=toc-toggle type=checkbox><label class=overlay for=toc-toggle></label><label title="Toggle Table of Contents" class=button for=toc-toggle id=toc-button><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="M414.82-193.094q-18.044 0-30.497-12.32-12.453-12.319-12.453-30.036t12.453-30.086q12.453-12.37 30.497-12.37h392.767q17.237 0 29.927 12.487 12.69 12.486 12.69 30.203 0 17.716-12.69 29.919t-29.927 12.203H414.82Zm0-244.833q-18.044 0-30.497-12.487Q371.87-462.9 371.87-480.45t12.453-29.92q12.453-12.369 30.497-12.369h392.767q17.237 0 29.927 12.511 12.69 12.512 12.69 29.845 0 17.716-12.69 30.086-12.69 12.37-29.927 12.37H414.82Zm0-245.167q-18.044 0-30.497-12.32t-12.453-30.037q0-17.716 12.453-30.086 12.453-12.369 30.497-12.369h392.767q17.237 0 29.927 12.486 12.69 12.487 12.69 30.203 0 17.717-12.69 29.92-12.69 12.203-29.927 12.203H414.82ZM189.379-156.681q-32.652 0-55.878-22.829t-23.226-55.731q0-32.549 23.15-55.647 23.151-23.097 55.95-23.097 32.799 0 55.313 23.484 22.515 23.484 22.515 56.246 0 32.212-22.861 54.893-22.861 22.681-54.963 22.681Zm0-245.167q-32.652 0-55.878-23.134-23.226-23.135-23.226-55.623 0-32.487 23.467-55.517t56.12-23.03q32.102 0 54.721 23.288 22.62 23.288 22.62 55.775 0 32.488-22.861 55.364-22.861 22.877-54.963 22.877Zm-.82-244.833q-32.224 0-55.254-23.288-23.03-23.289-23.03-55.623 0-32.333 23.271-55.364 23.272-23.03 55.495-23.03 32.224 0 55.193 23.288 22.969 23.289 22.969 55.622 0 32.334-23.21 55.364-23.21 23.031-55.434 23.031Z"/></svg></label><div class=toc-content><div class=toc-container><ul><li><a href=https://benashford.github.io/blog/2015/09/13/building-an-event-based-redis-client-in-java/#the-story-so-far>The story so far</a><li><a href=https://benashford.github.io/blog/2015/09/13/building-an-event-based-redis-client-in-java/#why-pipelining>Why pipelining?</a><li><a href=https://benashford.github.io/blog/2015/09/13/building-an-event-based-redis-client-in-java/#implicit-pipelining>Implicit pipelining</a><li><a href=https://benashford.github.io/blog/2015/09/13/building-an-event-based-redis-client-in-java/#conclusion>Conclusion</a> <ul><li><a href=https://benashford.github.io/blog/2015/09/13/building-an-event-based-redis-client-in-java/#footnotes>Footnotes</a></ul></ul></div></div></div><a title="Go to the top of the page" class=no-hover-padding href=# id=top-button> <svg viewbox="0 0 20 20" fill=currentColor><path d="M3.293 9.707a1 1 0 010-1.414l6-6a1 1 0 011.414 0l6 6a1 1 0 01-1.414 1.414L11 5.414V17a1 1 0 11-2 0V5.414L4.707 9.707a1 1 0 01-1.414 0z"/></svg> </a></div><span class=hidden id=copy-success> Copied! </span><span class=hidden id=copy-init> Copy code to clipboard </span><script defer src=https://benashford.github.io/js/copyCodeToClipboard.min.js></script></div><footer><section><nav class="socials nav-navs"><ul><li><a class="nav-links no-hover-padding social" rel=" me" href=https://github.com/benashford> <img alt=github loading=lazy src=https://benashford.github.io/social_icons/github.svg title=github> </a><li><a class="nav-links no-hover-padding social" rel=" me" href=https://uk.linkedin.com/in/benashford> <img alt=linkedin loading=lazy src=https://benashford.github.io/social_icons/linkedin.svg title=linkedin> </a></ul></nav><nav class=nav-navs></nav><div class=credits><small> Powered by <a href=https://www.getzola.org>Zola</a> & <a href=https://github.com/welpo/tabi>tabi</a> </small></div></section><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><h1 class=visually-hidden id=modalTitle>Search</h1><div id=modal-content><div id=searchBar><div aria-hidden=true class=search-icon><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="M784-120 532-372q-30 24-69 38t-83 14q-109 0-184.5-75.5T120-580q0-109 75.5-184.5T380-840q109 0 184.5 75.5T640-580q0 44-14 83t-38 69l252 252-56 56ZM380-400q75 0 127.5-52.5T560-580q0-75-52.5-127.5T380-760q-75 0-127.5 52.5T200-580q0 75 52.5 127.5T380-400Z"/></svg></div><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search… role=combobox spellcheck=false><div class="close-icon interactive-icon" title="Clear search" id=clear-search role=button tabindex=0><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></div></div><div id=results-container><div id=results-info><span id=zero_results> No results</span><span id=one_results> $NUMBER result</span><span id=many_results> $NUMBER results</span><span id=two_results> $NUMBER results</span><span id=few_results> $NUMBER results</span></div><div id=results role=listbox></div></div></div></div></footer><script src=https://benashford.github.io/js/lightbox.js></script>