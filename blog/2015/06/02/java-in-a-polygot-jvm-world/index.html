<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="default-src 'self';font-src 'self' data:;img-src 'self' https://* data:;media-src 'self';style-src 'self' 'unsafe-inline';frame-src player.vimeo.com https://www.youtube-nocookie.com https://www.youtube.com;connect-src 'self' benashford.goatcounter.com/count;script-src 'self' gc.zgo.at 'self'" http-equiv=Content-Security-Policy><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://benashford.github.io name=base><title>
Ben Ashford • Java in a polyglot JVM world</title><link href="https://benashford.github.io/custom_subset.css?h=0b9535a28bc3d5bf2321" rel=stylesheet><link href="https://benashford.github.io/main.css?h=3716ab3457d2dd050b3c" rel=stylesheet><link href="https://benashford.github.io/custom.css?h=8033382f2c68f07d12a3" rel=stylesheet><meta content="light dark" name=color-scheme><meta content="Mildly interesting technology stories." name=description><meta content="Mildly interesting technology stories." property=og:description><meta content="Java in a polyglot JVM world" property=og:title><meta content=article property=og:type><meta content=en_GB property=og:locale><link href=https://benashford.github.io/blog/2015/06/02/java-in-a-polygot-jvm-world/ rel=canonical><meta content=https://benashford.github.io/blog/2015/06/02/java-in-a-polygot-jvm-world/ property=og:url><meta content="Ben Ashford" property=og:site_name><noscript><link href=https://benashford.github.io/no_js.css rel=stylesheet></noscript><script src=https://benashford.github.io/js/initializeTheme.min.js></script><script defer src=https://benashford.github.io/js/themeSwitcher.min.js></script><script async data-goatcounter=https://benashford.goatcounter.com/count src=https://gc.zgo.at/count.js></script><script src="https://benashford.github.io/search_index.en.js?h=194ee059cb93d534a980" defer></script><script src="https://benashford.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><a href=#main-content id=skip-link>Skip to content</a><header><nav class=navbar><div class=nav-title><a class=home-title href=https://benashford.github.io/>Ben Ashford</a></div><div class=nav-navs><ul><li><a class="nav-links no-hover-padding" href=https://benashford.github.io/blog/>blog </a><li><a class="nav-links no-hover-padding" href=https://benashford.github.io/archive/>archive </a><li><a class="nav-links no-hover-padding" href=https://benashford.github.io/about/>about </a><li class=menu-icons-container><ul class=menu-icons-group><li class="js menu-icon"><div aria-label="Click or press $SHORTCUT to open search" class="search-icon interactive-icon" title="Click or press $SHORTCUT to open search" id=search-button role=button tabindex=0><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="M784-120 532-372q-30 24-69 38t-83 14q-109 0-184.5-75.5T120-580q0-109 75.5-184.5T380-840q109 0 184.5 75.5T640-580q0 44-14 83t-38 69l252 252-56 56ZM380-400q75 0 127.5-52.5T560-580q0-75-52.5-127.5T380-760q-75 0-127.5 52.5T200-580q0 75 52.5 127.5T380-400Z"/></svg></div><li class="theme-switcher-wrapper js"><div aria-label="Toggle dark mode" title="Toggle dark/light mode" aria-pressed=false class=theme-switcher role=button tabindex=0></div><div aria-label="Reset mode to default" class="theme-resetter arrow" title="Reset mode to default" aria-hidden=true role=button tabindex=0></div></ul></ul></div></nav></header><div class=content id=main-content><main><article class=h-entry><h1 class="p-name article-title">Java in a polyglot JVM world</h1><a class="u-url u-uid" href=https://benashford.github.io/blog/2015/06/02/java-in-a-polygot-jvm-world/></a><ul class=meta><span class="hidden p-author h-card"> <a class=u-url href=https://benashford.github.io rel=author></a> </span><li><time class=dt-published datetime=2015-06-02>2nd Jun 2015</time><li title="3005 words"><span aria-hidden=true class=separator>•</span>16 min read<li class=tag><span aria-hidden=true class=separator>•</span>Tags: <li class=tag><a class=p-category href=https://benashford.github.io/tags/clojure/>clojure</a>, <li class=tag><a class=p-category href=https://benashford.github.io/tags/java/>java</a>, <li class=tag><a class=p-category href=https://benashford.github.io/tags/jvm/>jvm</a></ul><section class="e-content body"><p>The trend over the last few years has been clear, the <a href=http://redmonk.com/dberkholz/2014/05/02/github-language-trends-and-the-fragmenting-landscape/>number of viable platforms from which to build software systems has been growing</a>. Not that many years ago, things would be either: Java, C++, Visual Basic or one of the many long-forgotten but once popular languages like Delphi. These days, things are either: JavaScript, Java (also: Clojure, Scala, Kotlin, Groovy), .NET (C#, F#), Ruby (including JRuby), Python (2 and 3, and all the interesting Python community sub-projects like PyPy and rpython), Rust, Go, C, C++, Haskell, OCaml, Erlang (and Elixir), Nim, Crystal, it goes on and on... Not every language is suitable to every task, but there's a surprisingly wide central area of suitability that nearly all of the above overlap.<p>Despite many online programming forums regressing to a continual flame-war on the subject of "which language will win"<sup class=footnote-reference><a href=#0>1</a></sup>, it's quite clear this fragmentation<sup class=footnote-reference><a href=#1>2</a></sup> is here to stay, at least for the forseeable future. Coupled with this is the habit of programmer communities forming language-tribes, which is a great shame as real-world code suffers as a result of tribal dogma<sup class=footnote-reference><a href=#2>3</a></sup><sup class=footnote-reference><a href=#2a>4</a></sup>.<p>I would be suspicious of any programmer who claimed to be an expert in all these programming languages, unless their name were Fabrice Bellard to TJ Holowaychuk perhaps. But I firmly believe in the principal of understanding multiple ways of doing things, there is no one-true-answer to everything (although there are nearly-one-true-answers to some things).<p>So, in todays diverse programming world, in which situations would you use an old, unfashionable, language like Java? Especially if you're already using a modern, fashionable, language like Clojure. They both target the JVM, so surely you'd use the newer one, unless there was an explicit need for performance. Actually, I would say no, there are a lot of problem-domains for which Java is very well suited.<h3 id=an-example>An example</h3><p>First, why Clojure? There has been a metaphorical avalanche of praise for Clojure the past few years, so I won't repeat the full list, not least because the full list includes things I don't really agree with; but there are many clear-cut advantages that Clojure has. By all means this list isn't unique to Clojure, pretty much everything in it also exists in at least one other language, and the benefits don't apply equally to all application domains; but the fact that they exist together, in a language that targets ubiquitous platforms (JVM, JavaScript, etc.) makes it a very good general-purpose programming language. For the record, I believe the key benefits of Clojure are: a) functional programming, not just a "functional optional" approach like Scala<sup class=footnote-reference><a href=#3>5</a></sup>; b) immutable data-structures and language support for STM, etc.; and c) macros<sup class=footnote-reference><a href=#4>6</a></sup>, and how that enables <code>core.async</code> and other such libraries.<p>A few months ago I had an idea for a side-project that required a bit of data-mining. My initial idea for the architecture was to use <code>core.async</code> as there were excellent asynchronous libraries available for both ends of the pipeline; however in the middle, to keep track of state and various pieces of transient data, I planned to use Redis. As it happened, I quickly realised the size of the data was small, so I implemented the whole thing in-memory in a single Ruby script instead, but that's another story; by this time the problem of how to talk to Redis in an application heavily based around <code>core.async</code> was firmly in my mind, so I deced to do something about it.<p>I'm aware of half-a-dozen Redis clients for Clojure, and have used a couple of those. The current market leader is the excellent <a href=https://github.com/ptaoussanis/carmine>Carmine</a><sup class=footnote-reference><a href=#5>7</a></sup>, it's fast, it's complete, what's not to like? However it does use blocking IO for most operations. Since beginning on <a href=https://github.com/benashford/redis-async>my client</a> I have become aware of other experimental forays into this area, but I wasn't aware of them at the time, and none of them look like the finished article.<p>(Incidentally, Carmine is a good project to read if you want to know how to write good idiomatic Clojure.)<h3 id=redis-async>redis-async</h3><p>My project <a href=https://github.com/benashford/redis-async><code>redis-async</code></a> quickly gained shape in my mind. It had the following design goals:<ul><li>To be a complete Redis client.<li>To be asynchronous, specifically non-blocking to any consumers.<li>To use <code>core.async</code> features (e.g. channels) rather than other mechanisms (e.g. callbacks or promises). This was mainly as I envisaged the need to integrate with other <code>core.async</code>-based code. Internally there may be callbacks, but the external interface would be channels.</ul><p>The complications were many and varied too. Not least the need to square a few circles regarding idiomacy; for example: a Redis string is what the Java/Clojure world would call a byte array - but yet most uses would require a Clojure/Java string; however there are some Redis commands where a consumer would require a byte array (<code>DUMP</code> and <code>RESTORE</code> plus others), so automatically converting would be incorrect.<p>The initial decision was how to go about this. There were three strands that went through my mind:<ol><li>Forget about the non-blocking IO entirely, Redis is fast, it's unlikely to cause deadlock, it'll just lead to an inefficient use of the threadpool that backs Go blocks. (I quickly dismissed this as being a dangerous path, there's no reason why talking to Redis couldn't be implemented asynchronously.)<li>To use <code>core.async</code> channels to communicate with one-or-more threads (i.e. full threads, not go blocks) that call Carmine functions. (Tempting, but again the Redis protocol isn't that complicated that the lack of an off-the-shelf library is a show-stopper.)<li>Implement the Redis protocol myself, and use a low-level non-blocking library for the networking.</ol><p>I chose Option 3.<p>The single major difference between synchronous and asynchronous communication, is how you go about reading the responses. Synchronously you would read from an <code>InputStream</code> until you have the data you are expecting (Redis is deterministic in this regard); if the data is not yet available, the thread will block until it is. Asynchronously, you will receieve a sequence of events, each of which contain an arbitrary amount of data; each event could contain multiple messages, but also an event may contain only part of a message; client code needs to combine multiple events to reconsititute a single message.<h4 id=the-redis-protocol>The Redis protocol</h4><p>The <a href=http://redis.io/topics/protocol>Redis protocol</a>, known as RESP, is designed to be simple to implement, that must be true because that's what it says at the top of its own documentation. It's made-up of a few simple types covering strings (byte-arrays), integers, arrays etc. It has a few fun peculiarities, like the fact that numbers are transmitted as strings, but this was done to make it human readable.<p>Communication both to and from a Redis server is a stream of RESP objects. A Redis command is just a RESP array where the elements are the command plus any options, each encoded as RESP. E.g. <code>SET KEY-NAME VALUE</code> is sent over the wire as <code>*3\r\n$3\r\nSET\r\n$8\r\nKEY-NAME\r\n$5\r\nVALUE\r\n</code><sup class=footnote-reference><a href=#6>8</a></sup><sup class=footnote-reference><a href=#7>9</a></sup>. Responses are similarly encoded, but the exact response varies according to the command; you can be sure that one command results in one response...<p>...except for those that don't. There are a number of commands with different semantics. Some like the "blocking" commands (e.g. <a href=http://redis.io/commands/BLPOP><code>BLPOP</code></a>) still return one command, but the client will have to wait for it if it's not already there; others like the various <a href=http://redis.io/topics/pubsub>Pub/Sub</a> commands will subscribe you to a channel and there will be an indefinite number of responses.<h4 id=the-first-iteration>The first iteration</h4><p>In any application space there are a number of libraries that are so widely adopted they're the de-facto choice. For asynchronous networking in Clojure, that library is <a href=https://github.com/ztellman/aleph>Aleph</a>, which in-turn is based around the venerable Java library <a href=http://netty.io>Netty</a>. Zach Tellman also owns a number of other good libraries which I would use in this first iteration, in particular <a href=https://github.com/ztellman/gloss>Gloss</a>.<p>Gloss was used to implement the Redis protocol, and Aleph used to transmit data back-and-forth. Gloss is very easy to integrate with Aleph and it handles the problem of messages being split over multiple callbacks, my code just read fully formed RESP messages.<p>Once this was up-and-running it was time for a quick benchmark against Carmine. Now, before I tell you the numbers, let me get my excuses in first: I was expecting it to be slower, for many reasons, but mainly two:<p>One, Carmine is very fast<sup class=footnote-reference><a href=#8>10</a></sup>, and the <a href=https://github.com/ptaoussanis/carmine/blob/master/src/taoensso/carmine/protocol.clj>code it uses for reading and parsing RESP</a> is very clean and straight forward. It essentially comes down to <a href=https://github.com/ptaoussanis/carmine/blob/master/src/taoensso/carmine/protocol.clj#L123-L189>one function</a> that reads the data from a Java <code>InputStream</code> into precise chunks. Asynchronous code would have to take a different approach, messages could be split across packets; even though this was handled for me by Gloss, it was still a runtime cost.<p>Two, Carmine is very direct. <code>redis-async</code> on the other hand would, by design, receive this incoming piece of data, route it to the waiting channel; somewhere else, in another thread, the arrival of this message would trigger the resumption of a go-block waiting on that channel; finally that code would do whatever it needed to do with the result. There was bound to be an overhead to all this.<p>So the results? First, the experiment: it was very basic, I would send 1,000 <code>PING</code> commands and wait for 1,000 <code>PONG</code>s to be returned.<p>Carmine achieved this in 2.66 milliseconds. <code>redis-async</code>, well, let's just say it had a 2 in it... it was in the hundreds of milliseconds.<p>Superficially they were doing the same thing, both were pipelining their commands. Carmine was returning a single result as a vector, however <code>redis-async</code> was distributing 1000 <code>PONG</code>s to their respective channels, which were then being waited on to be sure all the results were in. It was obvious that would take some time, but not 99% of a couple of hundred milliseconds worth. Surely?<p>It's also true-to-say that the chosen experiment was the one most likely to flatter Carmine given what was known about the implementation, and a more typical test would have produced a narrower result. But the gap was so massive I decided not to equivocate, the baseline would have to be improved either way.<h4 id=the-second-iteration>The second iteration</h4><p>A series of isolated tests on the individual layers showed that it was the de-serialization steps, going from binary to records that described the RESP types, was where the most time was being spent. And even more specifically, it was RESP's "simple strings" that were the problem. In my isolated test, replacing them with bulk strings made everything many times faster. But, since simple strings were in the protocol, this would have to be addressed.<p>I decided to drop Gloss, and implement the protocol myself. The reason was that I was rapidly accumulating extra cases to handle RESP, and the weight of these meant that Gloss was no-longer the simplest solution; the logic was lost amongst the workarounds.<p>The second iteration still used Aleph, but took the raw byte data and did all the parsing (and handling split messages) itself.<p>The results for the second iteration were much improved, but not stellar. It was in the low hundreds of milliseconds initially, which after a few tweaks, I got down to the ~90ms mark.<h3 id=where-java-fits-in-the-modern-polyglot-jvm-based-world>Where Java fits in the modern polyglot JVM-based world</h3><p>Looking at <a href=https://github.com/benashford/redis-async/blob/c0e34395bd20c2b0a84c47ddca4a7fdb6eb2da04/src/redis_async/protocol.clj>the code I had written</a> there was much to dislike. First, there was a lot of it for such a simple protocol; it was very low-level dealing with individual bytes and byte-buffers; it wasn't functionally pure, the buffers were mutable; there was a lot of other state, but all of it was passed around as a parameter.<p>The conclusion to this was obvious: why don't I just write it in Java? The Clojure version could be improved, just as the Gloss version in the previous iteration could have been; however, the direction I wanted to take (in both cases) was to move further away from the strength of those technologies. The game was stateful byte-by-byte manipulation, I might as well choose a starting point that makes that game easier to play.<h4 id=the-third-iteration>The third iteration</h4><p>I decided to split <code>redis-async</code> in two. Everything that was in <code>protocol.clj</code> or lower would be re-written in Java; everything else would stay in Clojure. This would mean the <a href=https://github.com/benashford/jresp>Java library, or JRESP - Java RESP</a> - would provide objects representing each RESP type (Array, Bulk String, Simple String, etc.), and also the means to read and write them to Redis instance.<p>Aleph was removed as a dependency, but Netty is still used by the Java code. What was the result?<ul><li>There's less code. You would expect a reduction of code going from Java to Clojure, not the other way around. The code is spread out over a much wider area however, on account of Java's one-public-class-per-file rule.<li>The code is conceptually simpler. The structure is obvious, and the areas were significant events occur (e.g. parsing data) are easily identified.<li>The state is held by the language making the logic easier to follow.</ul><p>The Clojure parts now simply call the <code>write</code> method on the <code>Connection</code> object to send a set of commands, the Clojure code also implements the callback from the <code>Connection</code> object, writing the result to the <code>core.async</code> channel that is used to allocate results back to specific channels.<sup class=footnote-reference><a href=#9>11</a></sup><p>So what about the performance? Well, there's good and bad news. The bad news is that the full-client is still slower than Carmine, but the time for 1000 <code>PING</code>/<code>PONG</code>s is under 50ms. The good news is that, by timing just the Java layer, the speed is significantly improved. Measured at that layer 1000 pings is 2.9ms.<p>Both the Java version, and it's Clojure predecessor, is unoptimised; so I have no doubt both could be made faster still. But comparing them both as initial versions is still interesting. While the revelation that Java is faster than Clojure will come as a shock to nobody, it can still be worth measuring as the gains are non-linear; and still the JRESP and Carmine code are both very similar (although JRESP is still doing more work to asynchronously read the result, albeit a small amount of extra work).<p>As for the remaining 47.5ms, which is spent entirely at the Clojure layer, I haven't investigated yet. It could be that this is the overhead of <code>core.async</code>. It could also be that the nature of the 1000 ping test is untypical and I should do more typical tests before coming to conclusions. Only then would I be able to put a price on this approach, then decide if such a cost actually works for the type of applications likely to use it.<p>The version of <code>redis-async</code> with JRESP is still in development. I'm intending on doing more performance testing and testing of edge-cases before releasing it.<h3 id=conclusion>Conclusion</h3><p>The conclusion, like all good conclusions, is retrospectively obvious: low-level logic is a good candidate for low-level languages. Perhaps not so obvious, especially with the modern zeitgeist of developer productivity being linked to expressiveness, is that low-level programming languages are the best medium for expressing low-level logic.<p>Java's role is essentially to be the C of the JVM. For writing code that is low-level, needs to be performant and/or needs to be shared across multiple JVM languages; it would be relatively easy to create a Scala Redis client based on JRESP, and even a full Java client for that matter.<h5 id=footnotes>Footnotes</h5><div class=footnote-definition id=0><sup class=footnote-definition-label>1</sup><p>Often this is a subtext of the actual topic at hand.</div><div class=footnote-definition id=1><sup class=footnote-definition-label>2</sup><p>I prefer the term "diversity".</div><div class=footnote-definition id=2><sup class=footnote-definition-label>3</sup><p>Once overheard: "we can't do that! If we use a SQL database, we're only one step away from Java!" All the while our competitors had a Java application based around a SQL database nicely satisfying all our potential customers without complaint...</div><div class=footnote-definition id=2a><sup class=footnote-definition-label>4</sup><p>Often such tribalism is rational, given those lines are often used in hiring practices.</div><div class=footnote-definition id=3><sup class=footnote-definition-label>5</sup><p>Although that might be beneficial for other reasons, at least the intent is clear.</div><div class=footnote-definition id=4><sup class=footnote-definition-label>6</sup><p>Dangerous, but revolutionary in the right hands.</div><div class=footnote-definition id=5><sup class=footnote-definition-label>7</sup><p>One of those impossible-to-Google project names.</div><div class=footnote-definition id=6><sup class=footnote-definition-label>8</sup><p>Yes, it's longer than just sending the string, this is normal; but it has removed ambiguity.</div><div class=footnote-definition id=7><sup class=footnote-definition-label>9</sup><p>For bulk string operations, those beginning with <code>$</code>, you are told the number of bytes to read but yet there's still a <code>\r\n</code> at the end. The final <code>\r\n</code> is a bit of a nuisance, as you need to add two to the number of bytes to read, then remove it again.</div><div class=footnote-definition id=8><sup class=footnote-definition-label>10</sup><p>As I said before, it's a very good project to read if you want to learn idiomatic (yet high performance) Clojure code. There's no fat in the entire project.</div><div class=footnote-definition id=9><sup class=footnote-definition-label>11</sup><p><em>Warning</em>: The Java code does not yet enforce any thread-safety, this is because the way it is currently used is guarenteed to come from only one thread at a time. This will change in the near future however, as this is an implementation detail of the Clojure implementation, and is likely not to be true for any other user of that library.</div></section></article></main><div id=button-container><div id=toc-floating-container><input class=toggle id=toc-toggle type=checkbox><label class=overlay for=toc-toggle></label><label title="Toggle Table of Contents" class=button for=toc-toggle id=toc-button><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="M414.82-193.094q-18.044 0-30.497-12.32-12.453-12.319-12.453-30.036t12.453-30.086q12.453-12.37 30.497-12.37h392.767q17.237 0 29.927 12.487 12.69 12.486 12.69 30.203 0 17.716-12.69 29.919t-29.927 12.203H414.82Zm0-244.833q-18.044 0-30.497-12.487Q371.87-462.9 371.87-480.45t12.453-29.92q12.453-12.369 30.497-12.369h392.767q17.237 0 29.927 12.511 12.69 12.512 12.69 29.845 0 17.716-12.69 30.086-12.69 12.37-29.927 12.37H414.82Zm0-245.167q-18.044 0-30.497-12.32t-12.453-30.037q0-17.716 12.453-30.086 12.453-12.369 30.497-12.369h392.767q17.237 0 29.927 12.486 12.69 12.487 12.69 30.203 0 17.717-12.69 29.92-12.69 12.203-29.927 12.203H414.82ZM189.379-156.681q-32.652 0-55.878-22.829t-23.226-55.731q0-32.549 23.15-55.647 23.151-23.097 55.95-23.097 32.799 0 55.313 23.484 22.515 23.484 22.515 56.246 0 32.212-22.861 54.893-22.861 22.681-54.963 22.681Zm0-245.167q-32.652 0-55.878-23.134-23.226-23.135-23.226-55.623 0-32.487 23.467-55.517t56.12-23.03q32.102 0 54.721 23.288 22.62 23.288 22.62 55.775 0 32.488-22.861 55.364-22.861 22.877-54.963 22.877Zm-.82-244.833q-32.224 0-55.254-23.288-23.03-23.289-23.03-55.623 0-32.333 23.271-55.364 23.272-23.03 55.495-23.03 32.224 0 55.193 23.288 22.969 23.289 22.969 55.622 0 32.334-23.21 55.364-23.21 23.031-55.434 23.031Z"/></svg></label><div class=toc-content><div class=toc-container><ul><li><a href=https://benashford.github.io/blog/2015/06/02/java-in-a-polygot-jvm-world/#an-example>An example</a><li><a href=https://benashford.github.io/blog/2015/06/02/java-in-a-polygot-jvm-world/#redis-async>redis-async</a> <ul><li><a href=https://benashford.github.io/blog/2015/06/02/java-in-a-polygot-jvm-world/#the-redis-protocol>The Redis protocol</a><li><a href=https://benashford.github.io/blog/2015/06/02/java-in-a-polygot-jvm-world/#the-first-iteration>The first iteration</a><li><a href=https://benashford.github.io/blog/2015/06/02/java-in-a-polygot-jvm-world/#the-second-iteration>The second iteration</a></ul><li><a href=https://benashford.github.io/blog/2015/06/02/java-in-a-polygot-jvm-world/#where-java-fits-in-the-modern-polyglot-jvm-based-world>Where Java fits in the modern polyglot JVM-based world</a> <ul><li><a href=https://benashford.github.io/blog/2015/06/02/java-in-a-polygot-jvm-world/#the-third-iteration>The third iteration</a></ul><li><a href=https://benashford.github.io/blog/2015/06/02/java-in-a-polygot-jvm-world/#conclusion>Conclusion</a> <ul><li><a href=https://benashford.github.io/blog/2015/06/02/java-in-a-polygot-jvm-world/#footnotes>Footnotes</a></ul></ul></div></div></div><a title="Go to the top of the page" class=no-hover-padding href=# id=top-button> <svg viewbox="0 0 20 20" fill=currentColor><path d="M3.293 9.707a1 1 0 010-1.414l6-6a1 1 0 011.414 0l6 6a1 1 0 01-1.414 1.414L11 5.414V17a1 1 0 11-2 0V5.414L4.707 9.707a1 1 0 01-1.414 0z"/></svg> </a></div><span class=hidden id=copy-success> Copied! </span><span class=hidden id=copy-init> Copy code to clipboard </span><script defer src=https://benashford.github.io/js/copyCodeToClipboard.min.js></script></div><footer><section><nav class="socials nav-navs"><ul><li><a class="nav-links no-hover-padding social" rel=" me" href=https://github.com/benashford> <img alt=github loading=lazy src=https://benashford.github.io/social_icons/github.svg title=github> </a><li><a class="nav-links no-hover-padding social" rel=" me" href=https://uk.linkedin.com/in/benashford> <img alt=linkedin loading=lazy src=https://benashford.github.io/social_icons/linkedin.svg title=linkedin> </a></ul></nav><nav class=nav-navs></nav><div class=credits><small> Powered by <a href=https://www.getzola.org>Zola</a> & <a href=https://github.com/welpo/tabi>tabi</a> </small></div></section><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><h1 class=visually-hidden id=modalTitle>Search</h1><div id=modal-content><div id=searchBar><div aria-hidden=true class=search-icon><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="M784-120 532-372q-30 24-69 38t-83 14q-109 0-184.5-75.5T120-580q0-109 75.5-184.5T380-840q109 0 184.5 75.5T640-580q0 44-14 83t-38 69l252 252-56 56ZM380-400q75 0 127.5-52.5T560-580q0-75-52.5-127.5T380-760q-75 0-127.5 52.5T200-580q0 75 52.5 127.5T380-400Z"/></svg></div><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search… role=combobox spellcheck=false><div class="close-icon interactive-icon" title="Clear search" id=clear-search role=button tabindex=0><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></div></div><div id=results-container><div id=results-info><span id=zero_results> No results</span><span id=one_results> $NUMBER result</span><span id=many_results> $NUMBER results</span><span id=two_results> $NUMBER results</span><span id=few_results> $NUMBER results</span></div><div id=results role=listbox></div></div></div></div></footer><script src=https://benashford.github.io/js/lightbox.js></script>