<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="default-src 'self';font-src 'self' data:;img-src 'self' https://* data:;media-src 'self';style-src 'self' 'unsafe-inline';frame-src player.vimeo.com https://www.youtube-nocookie.com https://www.youtube.com;connect-src 'self' benashford.goatcounter.com/count;script-src 'self' gc.zgo.at 'self'" http-equiv=Content-Security-Policy><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://benashford.github.io name=base><title>
Ben Ashford • Rust traits for developer friendly libraries</title><link href="https://benashford.github.io/custom_subset.css?h=0b9535a28bc3d5bf2321" rel=stylesheet><link href="https://benashford.github.io/main.css?h=3716ab3457d2dd050b3c" rel=stylesheet><link href="https://benashford.github.io/custom.css?h=8033382f2c68f07d12a3" rel=stylesheet><meta content="light dark" name=color-scheme><meta content="Mildly interesting technology stories." name=description><meta content="Mildly interesting technology stories." property=og:description><meta content="Rust traits for developer friendly libraries" property=og:title><meta content=article property=og:type><meta content=en_GB property=og:locale><link href=https://benashford.github.io/blog/2015/05/24/rust-traits-for-developer-friendly-libraries/ rel=canonical><meta content=https://benashford.github.io/blog/2015/05/24/rust-traits-for-developer-friendly-libraries/ property=og:url><meta content="Ben Ashford" property=og:site_name><noscript><link href=https://benashford.github.io/no_js.css rel=stylesheet></noscript><script src=https://benashford.github.io/js/initializeTheme.min.js></script><script defer src=https://benashford.github.io/js/themeSwitcher.min.js></script><script async data-goatcounter=https://benashford.goatcounter.com/count src=https://gc.zgo.at/count.js></script><script src="https://benashford.github.io/search_index.en.js?h=194ee059cb93d534a980" defer></script><script src="https://benashford.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><a href=#main-content id=skip-link>Skip to content</a><header><nav class=navbar><div class=nav-title><a class=home-title href=https://benashford.github.io/>Ben Ashford</a></div><div class=nav-navs><ul><li><a class="nav-links no-hover-padding" href=https://benashford.github.io/blog/>blog </a><li><a class="nav-links no-hover-padding" href=https://benashford.github.io/archive/>archive </a><li><a class="nav-links no-hover-padding" href=https://benashford.github.io/about/>about </a><li class=menu-icons-container><ul class=menu-icons-group><li class="js menu-icon"><div aria-label="Click or press $SHORTCUT to open search" class="search-icon interactive-icon" title="Click or press $SHORTCUT to open search" id=search-button role=button tabindex=0><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="M784-120 532-372q-30 24-69 38t-83 14q-109 0-184.5-75.5T120-580q0-109 75.5-184.5T380-840q109 0 184.5 75.5T640-580q0 44-14 83t-38 69l252 252-56 56ZM380-400q75 0 127.5-52.5T560-580q0-75-52.5-127.5T380-760q-75 0-127.5 52.5T200-580q0 75 52.5 127.5T380-400Z"/></svg></div><li class="theme-switcher-wrapper js"><div aria-label="Toggle dark mode" title="Toggle dark/light mode" aria-pressed=false class=theme-switcher role=button tabindex=0></div><div aria-label="Reset mode to default" class="theme-resetter arrow" title="Reset mode to default" aria-hidden=true role=button tabindex=0></div></ul></ul></div></nav></header><div class=content id=main-content><main><article class=h-entry><h1 class="p-name article-title">Rust traits for developer friendly libraries</h1><a class="u-url u-uid" href=https://benashford.github.io/blog/2015/05/24/rust-traits-for-developer-friendly-libraries/></a><ul class=meta><span class="hidden p-author h-card"> <a class=u-url href=https://benashford.github.io rel=author></a> </span><li><time class=dt-published datetime=2015-05-24>24th May 2015</time><li title="1561 words"><span aria-hidden=true class=separator>•</span>8 min read<li class=tag><span aria-hidden=true class=separator>•</span>Tags: <li class=tag><a class=p-category href=https://benashford.github.io/tags/rust/>rust</a></ul><section class="e-content body"><p>For the last six months or so, I've been looking more-and-more into <a href=/blog/2014/12/21/rust/>Rust</a>, and the more I look into it the more I like.<p>My latest Rust project has been to implement a <a href=https://github.com/benashford/rs-es>client to the ElasticSearch REST API</a>. I have implemented such things before, in different programming languages<sup class=footnote-reference><a href=#1>1</a></sup>, and recently came on an excuse to write one in Rust; the need to have such thing has long since passed but the process of writing it has been a good opportunity to delve more into Rust, and think about how to implement such things.<h3 id=the-elasticsearch-api>The ElasticSearch API</h3><p>The ElasticSearch API on it's surface is deceptively simple. It appears there is a simple convention in its URLs: <code>/index/type/id</code>, a RESTful convention for HTTP methods. The documents it indexes and returns are JSON documents which can be easily embedded in the JSON payloads that are submitted when searching and returned from various operations. And indeed, from many dynamic languages it is easy; that's because those languages, on account of being dynamic and having simple literal syntax for maps, these arbitrary chunks of JSON can be embedded and manipulated without much headache.<p>The first challenge, therefore, was to break away from that kind of thinking. Since Rust is not a dynamic language, and since it's design is very much aimed at systems programming, building an ElasticSearch client in Rust the same way I would in Clojure or Ruby would be both painful, and not taking advantage of Rust's strengths.<p>The cost of this has been the size of the library. It is already significantly bigger than previous ElasticSearch clients, and I've only started implementing it; there are many large areas so far untouched (e.g. aggregations). But the benefit is type-safety and hopefully self-explanatory code. By using enums to specifically list all legitimate values of a parameter, for instance, many invalid combinations will be discovered at compile time.<h3 id=the-query-dsl>The query DSL</h3><p>Many of the API end-points are relatively simple: a struct with a few optional values. The single biggest area of complication has been the <a href=https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html>Query DSL</a>; this consists of several dozen filters and queries, each of which has overlapping sets of slightly inconsistent options, many of which then go on to contain other filters and queries nested underneath.<p>The first challenge was how to write all the structs and enums and builder-functions necessary to capture all of this. That problem I solved by generating the majority of the code from templates. I might write more about this in a future blog post, but the current implementation is a bit gnarly, I intend to refactor it now it's mostly finished and I have the benefit of hindsight.<p>The second challenge is theoretically smaller, but also slightly trickier. This challenge is how to structure the Rust implementation so that users of my library can use this code without friction, and maybe even enjoy it.<h3 id=the-trivial-end-of-the-wedge>The trivial end of the wedge</h3><p>An example of the need to be friendly to potential users isn't even ElasticSearch specific, it's a common theme it seems with Rust code. Under what circumstances should a function borrow a string using <code>&str</code> and when should it require an owned <code>String</code> be moved in to its grasp?<p><a href=https://doc.rust-lang.org/book/strings.html>The Rust book recommends <code>&str</code></a> on the grounds that it's the cheapest option as it doesn't force the user to allocate a <code>String</code> especially. This makes a lot of sense, especially seeing as a <code>String</code> can be coerced to <code>&str</code> just by simply doing <code>&owned_string</code>. But on the other hand, the Query DSL needs an owned <code>String</code> because that's what the Json library needs; and many users of my library will be dynamically creating strings especially anyway, so would almost certainly own them; moving those would make sense, otherwise the path would be <code>String</code> to <code>&str</code> to a brand new <code>String</code> identical to the first one. However, I didn't want to enfore the use of <code>String</code> everywhere either, because a significant proportion of use-cases would have various strings (such as index names) as effective constants; forcing the user to allocate these strings everytime is just anti-social, if the library needs it the library should do it. I didn't want <code>"index_name".to_string()</code> everywhere.<p>The good thing about such fundamental questions is that there's a good chance someone else has already thought about them, and indeed <a href=http://hermanradtke.com/2015/05/06/creating-a-rust-function-that-accepts-string-or-str.html>Rust has a solution built in</a>, namely the <a href=https://doc.rust-lang.org/std/convert/trait.Into.html><code>Into</code> trait</a><sup class=footnote-reference><a href=#2>2</a></sup>.<p>By defining my functions to accept <code>Into&lt;String></code> I could accept both <code>String</code> and <code>&str</code>. If the user had an owned <code>String</code>, happy days, it'll be moved into place; if the user has a <code>&str</code>, then the library will allocate a <code>String</code> and carry on from there. But the user-friendliness is preserved. <code>my_function("constant_string")</code> and <code>my_function(format!("dynamic_{}", val))</code> both work.<p>It was at this stage I thought: "hang on a moment, if I accepted Into<miscellaneoustype> for everything, I could make any consumer code shorter and not lose any type-safety." <h3 id=the-more-complex-examples>The more complex examples</h3> <p>ElasticSearch's Query DSL has a number of dynamic context-specific fields. Values can be a single value or an array; the content could be a string, an integer, or even another map containing GeoJSON. This is a text-book example of Duck Typing, and clients in dynamic languages can just ignore it, just write the code you want and away you go.</p> <p>But my decision to go-with-the-flow regarding Rust, and therefore to make a type-safe client, meant I couldn't do that. But the first version was quite unpleasently verbose. To show the evolution of my approach, let's pick an example:</p> <h4 id=geo-bounding-box-filter>Geo Bounding Box filter</h4> <p>A <a href=https://www.elastic.co/guide/en/elasticsearch/reference/1.5/query-dsl-geo-bounding-box-filter.html>Geo Bounding Box filter</a> can be used to find documents which have a <code>geo_point</code> within the defined box. Sounds simple? It gets complex due to the number of options that a developer can use to define the box: either the corners (top-left, and bottom-right) can be provided, or the four (top, left, bottom, right) values can be given independently, but if corners are used those points can be defined in terms of lat-lng pairs or can be geohashes. I decided to support all of these options rather than force any consumers of <code>rs-es</code> to using a subset.</p> <p>There are certain options that can be ignored, however. ElasticSearch allows lat-lng pairs to be defined in a number of ways, either JSON:</p> <pre class=language-json data-lang=json style=color:#c0c5ce;background-color:#2b303b><code class=language-json data-lang=json><span>"</span><span style=color:#a3be8c>location</span><span>": {
</span><span>    "</span><span style=color:#a3be8c>lat</span><span>": </span><span style=color:#d08770>50.5</span><span>,
</span><span>    "</span><span style=color:#a3be8c>lon</span><span>": </span><span style=color:#d08770>-10.5
</span><span>}
</span></code></pre> <p>or arrays: <code>[-10.5, 50.5]</code> (note the lng-lat ordering), or even strings: <code>"50.5, -10.5"</code> (note the lat-lng ordering). All three are equivalent, so I can generate one and ignore the others.</p> <p>So to begin with, I need a enum defining choices for <code>GeoBox</code>:</p> <pre class=language-rust data-lang=rust style=color:#c0c5ce;background-color:#2b303b><code class=language-rust data-lang=rust><span style=color:#b48ead>pub enum </span><span>GeoBox {
</span><span>    Corners(Location, Location),
</span><span>    Vertices(</span><span style=color:#b48ead>f64</span><span>, </span><span style=color:#b48ead>f64</span><span>, </span><span style=color:#b48ead>f64</span><span>, </span><span style=color:#b48ead>f64</span><span>)
</span><span>}
</span></code></pre> <p>and another one for the choice of <code>Location</code>:</p> <pre class=language-rust data-lang=rust style=color:#c0c5ce;background-color:#2b303b><code class=language-rust data-lang=rust><span style=color:#b48ead>pub enum </span><span>Location {
</span><span>    LatLon(</span><span style=color:#b48ead>f64</span><span>, </span><span style=color:#b48ead>f64</span><span>),
</span><span>    GeoHash(String)
</span><span>}
</span></code></pre> <p>Putting it all together is where the horrible verbosity becomes apparent:</p> <pre class=language-rust data-lang=rust style=color:#c0c5ce;background-color:#2b303b><code class=language-rust data-lang=rust><span>Filter::build_geo_bounding_box("</span><span style=color:#a3be8c>pin</span><span>")
</span><span>    .</span><span style=color:#96b5b4>with_geo_box</span><span>(GeoBox::Corners(Location::LatLon(</span><span style=color:#d08770>50.5</span><span>, -</span><span style=color:#d08770>10.5</span><span>),
</span><span>                                  Location::LatLon(</span><span style=color:#d08770>50.0</span><span>, -</span><span style=color:#d08770>10.0</span><span>)))
</span><span>    .</span><span style=color:#96b5b4>build</span><span>();
</span></code></pre> <p>Not great compared to the JSON it produces, although arguably easier to understand:</p> <pre class=language-json data-lang=json style=color:#c0c5ce;background-color:#2b303b><code class=language-json data-lang=json><span>"</span><span style=color:#a3be8c>geo_bounding_box</span><span>": {
</span><span>   "</span><span style=color:#a3be8c>pin</span><span>": {
</span><span>       "</span><span style=color:#a3be8c>top_left</span><span>": {"</span><span style=color:#a3be8c>lat</span><span>": </span><span style=color:#d08770>50.5</span><span>, "</span><span style=color:#a3be8c>lon</span><span>": </span><span style=color:#d08770>-10.5</span><span>},
</span><span>       "</span><span style=color:#a3be8c>bottom_right</span><span>": {"</span><span style=color:#a3be8c>lat</span><span>": </span><span style=color:#d08770>50.0</span><span>, "</span><span style=color:#a3be8c>lon</span><span>": </span><span style=color:#d08770>-10.0</span><span>}
</span><span>   }
</span><span>}
</span></code></pre> <h3 id=so-traits>So... traits?</h3> <p>The solution to the verbosity problem was obvious after solving my <code>String</code> vs. <code>&str</code> problem. I would define the <code>with_geo_box</code> function, and any other such function, to take anything that implements <code>Into&lt;GeoBox></code> rather than just <code>GeoBox</code>. This means that the full verbose option still works if you want to write it in full, but this approach also allows various shortcuts.</p> <p>For example, the verbose example above could be written:</p> <pre class=language-rust data-lang=rust style=color:#c0c5ce;background-color:#2b303b><code class=language-rust data-lang=rust><span>Filter::build_geo_bounding_box("</span><span style=color:#a3be8c>pin</span><span>")
</span><span>    .</span><span style=color:#96b5b4>with_geo_box</span><span>(((</span><span style=color:#d08770>50.5</span><span>, -</span><span style=color:#d08770>10.5</span><span>), (</span><span style=color:#d08770>50.0</span><span>, -</span><span style=color:#d08770>10.0</span><span>)))
</span><span>    .</span><span style=color:#96b5b4>build</span><span>();
</span></code></pre> <p>This is because the tuple <code>((f64, f64), (f64, f64))</code> implements <code>Into&lt;GeoBox></code>. Similar provisions are made for <code>(f64, f64, f64, f64)</code> for the <code>Vertices</code> version, and for <code>(String, String)</code> for the geohash version. This is achieved by simply implementing the <code>From&lt;whatever> for Geobox</code> trait for each required combination:</p> <pre class=language-rust data-lang=rust style=color:#c0c5ce;background-color:#2b303b><code class=language-rust data-lang=rust><span style=color:#b48ead>impl </span><span>From&lt;(</span><span style=color:#b48ead>f64</span><span>, </span><span style=color:#b48ead>f64</span><span>, </span><span style=color:#b48ead>f64</span><span>, </span><span style=color:#b48ead>f64</span><span>)> </span><span style=color:#b48ead>for </span><span>GeoBox {
</span><span>    </span><span style=color:#b48ead>fn </span><span style=color:#8fa1b3>from</span><span>(</span><span style=color:#bf616a>from</span><span>: (</span><span style=color:#bf616a>f64</span><span>, </span><span style=color:#bf616a>f64</span><span>, </span><span style=color:#bf616a>f64</span><span>, </span><span style=color:#bf616a>f64</span><span>)) -> GeoBox {
</span><span>        GeoBox::Vertices(from.</span><span style=color:#d08770>0</span><span>, from.</span><span style=color:#d08770>1</span><span>, from.</span><span style=color:#d08770>2</span><span>, from.</span><span style=color:#d08770>3</span><span>)
</span><span>    }
</span><span>}
</span></code></pre> <p>and so on.</p> <p>Of course having to write five nearly identical lines for very similar functions has a high noise-to-signal ratio, but fortunately Rust has macros, after defining a couple of macros the above then becomes a one-liner:</p> <pre class=language-rust data-lang=rust style=color:#c0c5ce;background-color:#2b303b><code class=language-rust data-lang=rust><span>from_exp!((</span><span style=color:#b48ead>f64</span><span>, </span><span style=color:#b48ead>f64</span><span>, </span><span style=color:#b48ead>f64</span><span>, </span><span style=color:#b48ead>f64</span><span>), GeoBox, from, GeoBox::Vertices(from.</span><span style=color:#d08770>0</span><span>, from.</span><span style=color:#d08770>1</span><span>, from.</span><span style=color:#d08770>2</span><span>, from.</span><span style=color:#d08770>3</span><span>));
</span></code></pre> <p>The code behind this is in the template that the code-generator uses to produce the full implementation of the Query DSL. This can be <a href=https://github.com/benashford/rs-es/blob/master/templates/query.rs.erb#L27>seen here</a>.</p> <p>There is one final, but quite significant, advantage to the use of these conversion traits; the fact that any application could implement their own. It would be quite likely that a hypothetical future application that needs a filter such as <code>geo_bounding_box</code> would already have defined something analogous to a <code>GeoBox</code>; rather than having to convert between the two at the point where a search happens, the <code>From&lt;OtherType></code> trait could be implemented for <code>GeoBox</code> allowing it to be dropped straight in.</p> <h3 id=conclusion>Conclusion</h3> <p>This has been applied essentially everywhere in the code that implements the Query DSL, and it shows that using simple traits can have a big impact in the design of APIs.</p> <p>There are still many challenges, as various parts of the ElasticSearch API are subtly inconsistent however.</p> <h5 id=footnotes>Footnotes</h5> <div class=footnote-definition id=1><sup class=footnote-definition-label>1</sup><p>I've written 2.5 such clients in Clojure alone, the .5 is a half-finished implementation I'm intending on open-sourcing eventually.</div> <div class=footnote-definition id=2><sup class=footnote-definition-label>2</sup><p>And its related cousin, the <a href=https://doc.rust-lang.org/std/convert/trait.From.html><code>From</code> trait</a>.</div> <div id=button-container><div id=toc-floating-container><input class=toggle id=toc-toggle type=checkbox><label class=overlay for=toc-toggle></label><label title="Toggle Table of Contents" class=button for=toc-toggle id=toc-button><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="M414.82-193.094q-18.044 0-30.497-12.32-12.453-12.319-12.453-30.036t12.453-30.086q12.453-12.37 30.497-12.37h392.767q17.237 0 29.927 12.487 12.69 12.486 12.69 30.203 0 17.716-12.69 29.919t-29.927 12.203H414.82Zm0-244.833q-18.044 0-30.497-12.487Q371.87-462.9 371.87-480.45t12.453-29.92q12.453-12.369 30.497-12.369h392.767q17.237 0 29.927 12.511 12.69 12.512 12.69 29.845 0 17.716-12.69 30.086-12.69 12.37-29.927 12.37H414.82Zm0-245.167q-18.044 0-30.497-12.32t-12.453-30.037q0-17.716 12.453-30.086 12.453-12.369 30.497-12.369h392.767q17.237 0 29.927 12.486 12.69 12.487 12.69 30.203 0 17.717-12.69 29.92-12.69 12.203-29.927 12.203H414.82ZM189.379-156.681q-32.652 0-55.878-22.829t-23.226-55.731q0-32.549 23.15-55.647 23.151-23.097 55.95-23.097 32.799 0 55.313 23.484 22.515 23.484 22.515 56.246 0 32.212-22.861 54.893-22.861 22.681-54.963 22.681Zm0-245.167q-32.652 0-55.878-23.134-23.226-23.135-23.226-55.623 0-32.487 23.467-55.517t56.12-23.03q32.102 0 54.721 23.288 22.62 23.288 22.62 55.775 0 32.488-22.861 55.364-22.861 22.877-54.963 22.877Zm-.82-244.833q-32.224 0-55.254-23.288-23.03-23.289-23.03-55.623 0-32.333 23.271-55.364 23.272-23.03 55.495-23.03 32.224 0 55.193 23.288 22.969 23.289 22.969 55.622 0 32.334-23.21 55.364-23.21 23.031-55.434 23.031Z"/></svg></label><div class=toc-content><div class=toc-container><ul><li><a href=https://benashford.github.io/blog/2015/05/24/rust-traits-for-developer-friendly-libraries/#the-elasticsearch-api>The ElasticSearch API</a><li><a href=https://benashford.github.io/blog/2015/05/24/rust-traits-for-developer-friendly-libraries/#the-query-dsl>The query DSL</a><li><a href=https://benashford.github.io/blog/2015/05/24/rust-traits-for-developer-friendly-libraries/#the-trivial-end-of-the-wedge>The trivial end of the wedge</a><li><a href=https://benashford.github.io/blog/2015/05/24/rust-traits-for-developer-friendly-libraries/#the-more-complex-examples>The more complex examples</a> <ul><li><a href=https://benashford.github.io/blog/2015/05/24/rust-traits-for-developer-friendly-libraries/#geo-bounding-box-filter>Geo Bounding Box filter</a></ul><li><a href=https://benashford.github.io/blog/2015/05/24/rust-traits-for-developer-friendly-libraries/#so-traits>So... traits?</a><li><a href=https://benashford.github.io/blog/2015/05/24/rust-traits-for-developer-friendly-libraries/#conclusion>Conclusion</a> <ul><li><a href=https://benashford.github.io/blog/2015/05/24/rust-traits-for-developer-friendly-libraries/#footnotes>Footnotes</a></ul></ul></div></div></div><a title="Go to the top of the page" class=no-hover-padding href=# id=top-button> <svg viewbox="0 0 20 20" fill=currentColor><path d="M3.293 9.707a1 1 0 010-1.414l6-6a1 1 0 011.414 0l6 6a1 1 0 01-1.414 1.414L11 5.414V17a1 1 0 11-2 0V5.414L4.707 9.707a1 1 0 01-1.414 0z"/></svg> </a></div> <span class=hidden id=copy-success> Copied! </span> <span class=hidden id=copy-init> Copy code to clipboard </span> <script defer src=https://benashford.github.io/js/copyCodeToClipboard.min.js></script> <footer><section><nav class="socials nav-navs"><ul><li><a class="nav-links no-hover-padding social" rel=" me" href=https://github.com/benashford> <img alt=github loading=lazy src=https://benashford.github.io/social_icons/github.svg title=github> </a><li><a class="nav-links no-hover-padding social" rel=" me" href=https://uk.linkedin.com/in/benashford> <img alt=linkedin loading=lazy src=https://benashford.github.io/social_icons/linkedin.svg title=linkedin> </a></ul></nav><nav class=nav-navs></nav><div class=credits><small> Powered by <a href=https://www.getzola.org>Zola</a> & <a href=https://github.com/welpo/tabi>tabi</a> </small></div></section><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><h1 class=visually-hidden id=modalTitle>Search</h1><div id=modal-content><div id=searchBar><div aria-hidden=true class=search-icon><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="M784-120 532-372q-30 24-69 38t-83 14q-109 0-184.5-75.5T120-580q0-109 75.5-184.5T380-840q109 0 184.5 75.5T640-580q0 44-14 83t-38 69l252 252-56 56ZM380-400q75 0 127.5-52.5T560-580q0-75-52.5-127.5T380-760q-75 0-127.5 52.5T200-580q0 75 52.5 127.5T380-400Z"/></svg></div><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search… role=combobox spellcheck=false><div class="close-icon interactive-icon" title="Clear search" id=clear-search role=button tabindex=0><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></div></div><div id=results-container><div id=results-info><span id=zero_results> No results</span><span id=one_results> $NUMBER result</span><span id=many_results> $NUMBER results</span><span id=two_results> $NUMBER results</span><span id=few_results> $NUMBER results</span></div><div id=results role=listbox></div></div></div></div></footer> <script src=https://benashford.github.io/js/lightbox.js></script> 